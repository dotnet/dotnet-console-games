using System;
using System.Diagnostics;
using System.Threading.Tasks;

namespace Website.Games.Pong;

public class Pong
{
	public readonly BlazorConsole Console = new();

	public async Task Run()
	{
		int width = Console.WindowWidth;
		int height = Console.WindowHeight;
		float multiplier = 1.1f;
		Random random = new();
		TimeSpan delay = TimeSpan.FromMilliseconds(10);
		TimeSpan enemyInputDelay = TimeSpan.FromMilliseconds(100);
		int paddleSize = height / 4;
		Stopwatch stopwatch = new();
		Stopwatch enemyStopwatch = new();
		int scoreA = 0;
		int scoreB = 0;
		Ball ball;
		int paddleA = height / 3;
		int paddleB = height / 3;

		await Console.Clear();
		stopwatch.Restart();
		enemyStopwatch.Restart();
		Console.CursorVisible = false;
		while (scoreA < 3 && scoreB < 3)
		{
			ball = CreateNewBall();
			while (true)
			{
				#region Update Ball

				// Compute Time And New Ball Position
				float time = (float)stopwatch.Elapsed.TotalSeconds * 15;
				var (X2, Y2) = (ball.X + (time * ball.dX), ball.Y + (time * ball.dY));

				// Collisions With Up/Down Walls
				if (Y2 < 0 || Y2 > height)
				{
					ball.dY = -ball.dY;
					Y2 = ball.Y + ball.dY;
				}

				// Collision With Paddle A
				if (Math.Min(ball.X, X2) <= 2 && 2 <= Math.Max(ball.X, X2))
				{
					int ballPathAtPaddleA = height - (int)GetLineValue(((ball.X, height - ball.Y), (X2, height - Y2)), 2);
					ballPathAtPaddleA = Math.Max(0, ballPathAtPaddleA);
					ballPathAtPaddleA = Math.Min(height - 1, ballPathAtPaddleA);
					if (paddleA <= ballPathAtPaddleA && ballPathAtPaddleA <= paddleA + paddleSize)
					{
						ball.dX = -ball.dX;
						ball.dX *= multiplier;
						ball.dY *= multiplier;
						X2 = ball.X + (time * ball.dX);
					}
				}

				// Collision With Paddle B
				if (Math.Min(ball.X, X2) <= width - 2 && width - 2 <= Math.Max(ball.X, X2))
				{
					int ballPathAtPaddleB = height - (int)GetLineValue(((ball.X, height - ball.Y), (X2, height - Y2)), width - 2);
					ballPathAtPaddleB = Math.Max(0, ballPathAtPaddleB);
					ballPathAtPaddleB = Math.Min(height - 1, ballPathAtPaddleB);
					if (paddleB <= ballPathAtPaddleB && ballPathAtPaddleB <= paddleB + paddleSize)
					{
						ball.dX = -ball.dX;
						ball.dX *= multiplier;
						ball.dY *= multiplier;
						X2 = ball.X + (time * ball.dX);
					}
				}

				// Collisions With Left/Right Walls
				if (X2 < 0)
				{
					scoreB++;
					break;
				}
				if (X2 > width)
				{
					scoreA++;
					break;
				}

				// Updating Ball Position
				await Console.SetCursorPosition((int)ball.X, (int)ball.Y);
				await Console.Write(' ');
				ball.X += time * ball.dX;
				ball.Y += time * ball.dY;
				await Console.SetCursorPosition((int)ball.X, (int)ball.Y);
				await Console.Write('O');

				#endregion

				#region Update Player Paddle

				if (await Console.KeyAvailable())
				{
					switch ((await Console.ReadKey(true)).Key)
					{
						case ConsoleKey.UpArrow: paddleA = Math.Max(paddleA - 1, 0); break;
						case ConsoleKey.DownArrow: paddleA = Math.Min(paddleA + 1, height - paddleSize - 1); break;
						case ConsoleKey.Escape:
							await Console.Clear();
							await Console.Write("Pong was closed.");
							await Console.Refresh();
							return;
					}
				}
				while (await Console.KeyAvailable())
				{
					await Console.ReadKey(true);
				}

				#endregion

				#region Update Computer Paddle

				if (enemyStopwatch.Elapsed > enemyInputDelay)
				{
					if (ball.Y < paddleB + (paddleSize / 2) && ball.dY < 0)
					{
						paddleB = Math.Max(paddleB - 1, 0);
					}
					else if (ball.Y > paddleB + (paddleSize / 2) && ball.dY > 0)
					{
						paddleB = Math.Min(paddleB + 1, height - paddleSize - 1);
					}
					enemyStopwatch.Restart();
				}

				#endregion

				#region Render Paddles

				for (int i = 0; i < height; i++)
				{
					await Console.SetCursorPosition(2, i);
					await Console.Write(paddleA <= i && i <= paddleA + paddleSize ? '█' : ' ');
					await Console.SetCursorPosition(width - 2, i);
					await Console.Write(paddleB <= i && i <= paddleB + paddleSize ? '█' : ' ');
				}

				#endregion

				stopwatch.Restart();
				await Console.RefreshAndDelay(delay);
			}
			await Console.SetCursorPosition((int)ball.X, (int)ball.Y);
			await Console.Write(' ');
		}
		await Console.Clear();
		if (scoreA > scoreB)
		{
			await Console.Write("You win.");
		}
		if (scoreA < scoreB)
		{
			await Console.Write("You lose.");
		}
		await Console.Refresh();

		Ball CreateNewBall()
		{
			float randomFloat = (float)random.NextDouble() * 2f;
			float dx = Math.Max(randomFloat, 1f - randomFloat);
			float dy = 1f - dx;
			float x = width / 2;
			float y = height / 2;
			if (random.Next(2) == 0)
			{
				dx = -dx;
			}
			if (random.Next(2) == 0)
			{
				dy = -dy;
			}
			return new Ball
			{
				X = x,
				Y = y,
				dX = dx,
				dY = dy,
			};
		}

		float GetLineValue(((float X, float Y) A, (float X, float Y) B) line, float x)
		{
			// order points from least to greatest X
			if (line.B.X < line.A.X)
			{
				(line.A, line.B) = (line.B, line.A);
			}
			// find the slope
			float slope = (line.B.Y - line.A.Y) / (line.B.X - line.A.X);
			// find the y-intercept
			float yIntercept = line.A.Y - line.A.X * slope;
			// find the function's value at parameter "x"
			return x * slope + yIntercept;
		}
	}

	public class Ball
	{
		public float X;
		public float Y;
		public float dX;
		public float dY;
	}
}
